import{_ as e,c as l,o as a,a as d}from"./app.43496e99.js";const f=JSON.parse('{"title":"Unreal 智能指针","description":"","frontmatter":{},"headers":[{"level":2,"title":"基本模板类","slug":"基本模板类","link":"#基本模板类","children":[]},{"level":2,"title":"引用计数控制器","slug":"引用计数控制器","link":"#引用计数控制器","children":[]},{"level":2,"title":"工具函数","slug":"工具函数","link":"#工具函数","children":[]}],"relativePath":"basic/pointer.md","lastUpdated":1660026515000}'),r={name:"basic/pointer.md"},o=d('<h1 id="unreal-智能指针" tabindex="-1">Unreal 智能指针 <a class="header-anchor" href="#unreal-智能指针" aria-hidden="true">#</a></h1><p><a href="https://docs.unrealengine.com/5.0/zh-CN/smart-pointers-in-unreal-engine/" target="_blank" rel="noreferrer">官方文档</a></p><p>Unreal 没有使用 C++ 标准库中的智能指针，而是自定义了一套智能指针库。相较于标准库实现，Unreal 智能指针库有如下特点：</p><ul><li>语法简洁：使用方法与标准库类似，并且实现了智能引用。</li><li>可选的线程安全：提供线程安全实现供开发者选择，关闭可获得更快的速度。</li><li>全平台支持：C++ 标准库不能提供全游戏平台的支持。</li><li>低内存占用：64-bit 系统下内存占用仅为 16 字节，两倍原生指针大小。</li><li>无外部依赖：完全由 Unreal 核心库和 C++ 原生语法实现。</li></ul><h2 id="基本模板类" tabindex="-1">基本模板类 <a class="header-anchor" href="#基本模板类" aria-hidden="true">#</a></h2><p><code>TSharedRef&lt;&gt;</code></p><ul><li>智能引用，拥有与 C++ 引用相似的特性，但实现方式仍为对原生指针的拓展</li><li>非空，构造时需传入有效对象</li><li>参与引用计数，拥有所有权</li></ul><p><code>TSharedPtr&lt;&gt;</code></p><ul><li>智能指针，拥有与 C++ 指针相似的特性，实现方式为对原生指针的拓展。</li><li>参与引用计数，拥有所有权</li></ul><p><code>TWeakPtr&lt;&gt;</code></p><ul><li>弱指针，拥有与 C++ 指针相似的特性，实现方式为对原生指针的拓展。</li><li>不参与引用计数，不拥有所有权</li></ul><p>从性能和安全性的角度考虑，在可使用智能引用的场景下，应优先选择使用智能引用。</p><h2 id="引用计数控制器" tabindex="-1">引用计数控制器 <a class="header-anchor" href="#引用计数控制器" aria-hidden="true">#</a></h2><p>Unreal 智能指针的引用计数表由 <code>ReferenceController</code> 维护，大小仅 16 字节。每个控制器拥有 <code>SharedReferenceCount</code> 和 <code>WeakReferenceCount</code> 两个计数器，分别记录智能指针（或引用）与弱指针的数量。</p><p>一个智能指针控制器的生命周期如下：</p><ul><li>实例化：在 <code>ReferenceController</code> 对象被构造时，两个计数器的值均初始化为 <code>1</code></li><li>增加计数： <ul><li>在智能指针（或引用）的拷贝构造函数中增加计数器 <code>SharedReferenceCount</code> 计数</li><li>在弱指针的拷贝构造函数中增加计数器 <code>WeakReferenceCount</code> 计数</li></ul></li><li>减少计数： <ul><li>在智能指针（或引用）的析构函数中减少计数器 <code>SharedReferenceCount</code> 计数</li><li>在弱指针的析构函数中减少计数器 <code>WeakReferenceCount</code> 计数</li></ul></li><li>释放：当计数器 <code>SharedReferenceCount</code> 减少至 <code>0</code> 时，意味着当前引用对象已经没有有效的智能指针（或引用）存在。控制器将调用 <code>DestroyObject()</code> 方法释放引用对象，同时释放指向该对象的所有弱指针与控制器本身。<code>DestroyObject()</code> 方法默认使用 <code>delete</code> 操作符释放对象，也可在智能指针构造时传入自定义的 Deleter 。</li></ul><h2 id="工具函数" tabindex="-1">工具函数 <a class="header-anchor" href="#工具函数" aria-hidden="true">#</a></h2><p><code>MakeShared&lt;&gt;()</code> 注册智能指针，将控制器和引用对象初始化在连续的内存上</p><p><code>MakeSharable()</code> 转换原生指针为智能指针</p><p><code>TSharedPtr::Reset()</code> 强制释放引用对象和控制器</p><p><code>StaticCastSharedRef()</code> <code>ConstCastSharedRef()</code> 智能引用类型转换</p><p><code>StaticCastSharedPtr()</code> <code>ConstCastSharedPtr()</code> 智能指针类型转换</p>',22),t=[o];function c(i,n,h,s,p,u){return a(),l("div",null,t)}const C=e(r,[["render",c]]);export{f as __pageData,C as default};
